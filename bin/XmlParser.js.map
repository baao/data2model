{"version":3,"sources":["XmlParser.es6"],"names":[],"mappings":"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","file":"XmlParser.js","sourcesContent":["/**\n * data2model\n * Author: michael\n * Date: 19.09.15.\n * License: MIT\n */\n'use strict';\nconst sax = require('sax');\nconst Promise = require('bluebird');\nconst fs = Promise.promisifyAll(require('fs-extra'));\nconst log = require('deep-logger').deepLogger;\nconst __ = require('le-map-e');\nconst appRoot = require('app-root-path');\nconst reqLib = appRoot.require;\n\nclass XmlParser {\n    constructor(options) {\n        if (!options) options = {};\n        this.options = Object.assign({\n            shouldQueryNow: true,\n            useStrict: true\n        }, options);\n        this.parser = new sax.parser(this.options.useStrict);\n        this.models = [];\n    }\n\n    handleModel(models) {\n        return models.map(val => reqLib(`/models/${val}.js`));\n    }\n\n    parse(xml, models, options) {\n        let pr = (this.handleModel(models));\n        return Promise.all(pr).then(val => {\n            let models = new Map();\n            let toFind = new Map();\n            let tagToName = new Map();\n            val.forEach(v => {\n                let options = {\n                    database: this.options.database,\n                    shouldQueryNow: this.options.shouldQueryNow\n                };\n                let model = new v(options);\n                this.models.push(model);\n                let colsToFind = Object.keys(model.columns).filter(val => model.columns[val].find).map(v => model.columns[v].find);\n                let colsToBeEqual = Object.keys(model.columns).filter(val => model.columns[val].equals).map(v => [model.columns[v].equals, v]);\n                let tags = Object.keys(model.columns).filter(val => model.columns[val].find).map(v => [model.columns[v].find, v]);\n                let valueOptions = Object.keys(model.columns).filter(val => model.columns[val].valueOptions).map(v => [v, model.columns[v].valueOptions]);\n                models.set(model.constructor.name, new Map([\n                    ['groupBy', model.groupBy],\n                    ['toFind', colsToFind],\n                    [\n                        'foundValues', (() => {\n                        let values = new Map();\n                        Object.keys(model.columns).filter(val => model.columns[val].defaultValue).forEach(data => {\n                            values.set(data, model.columns[data].defaultValue)\n                        });\n                        return values;\n                    })()\n                    ],\n                    ['equalCols', new Map(colsToBeEqual)],\n                    ['valueOptions', new Map(valueOptions)]\n                ]));\n                colsToFind.forEach(col => {\n                    toFind.setOrCombine(col, [model.constructor.name]);\n                });\n                tags.forEach(tag => {\n                    tagToName.setOrCombine(tag[0], [tag[1]]);\n                });\n\n            });\n            return [models, toFind, tagToName];\n        }).spread((models, toFind, tagToName) => {\n            let results = new Set(),\n                foundNext = false;\n            this.parser.onopentag = node => {\n                let parser = this.parser,\n                    tagName = this.createDotNotation(parser.tags, parser.tag.name);\n                if (toFind.has(tagName) && parser.tag.isSelfClosing == true) {\n                    results.deepMapAppendOrNew(tagToName.get(tagName), '');\n                }\n            };\n            this.parser.ontext = text => {\n                let parser = this.parser,\n                    textNode = text.replace(/\\\\n/g, '').trim(),\n                    tagName = this.createDotNotation(parser.tags, parser.tag.name);\n                if (toFind.has(tagName) && textNode !== '') {\n                    results.deepMapAppendOrNew(tagToName.get(tagName), this.valueFunctions(textNode, tagToName.get(tagName), models))\n                }\n                /*if (!foundNext && toFind.has(textNode + ':' + tagName) && textNode !== '') {\n                 foundNext = tagToName.get(textNode + ':' + tagName);\n                 } else if (foundNext && toFind.has(textNode + ':' + tagName) && textNode !== ''){\n                 for (let val of models.values()) {\n                 val.get('toFind').forEach(data => {\n                 if (tagToName.get(data) == foundNext) {\n                 results.deepMapAppendOrNew(tagToName.get(data), this.valueFunctions(textNode, tagToName.get(data), models));\n                 }\n                 })\n                 }\n                 foundNext = false;\n                 }*/\n            };\n            this.parser.write(xml);\n            return [results, models, toFind, tagToName];\n        }).spread((res, models, toFind, tagToName) => {\n            let toFill = new Map();\n            let resultGroup;\n            this.parser.close();\n            for (let [modelName, modelData] of models.entries()) {\n                let finder = new Map();\n                res.forEach(result => {\n                    let foundValues = new Map();\n                    let flattenedUnique = Array.from(result.keys())\n                        .reduce((a, b) => a.concat(b))\n                        .filter((item, pos, self) => self.indexOf(item) == pos);\n                    flattenedUnique.forEach(col => {\n                            modelData.get('toFind').forEach(val => {\n                                if (~tagToName.get(val).indexOf(col)) {\n                                    for (let [k,v] of result.entries()) {\n                                        if (~k.indexOf(col)) {\n                                            foundValues.set(col, v)\n                                        }\n                                    }\n                                }\n                            });\n                        });\n                    if (modelData.get('groupBy').length > 0) {\n                        modelData.get('groupBy').forEach(group => {\n                            if (~flattenedUnique.indexOf(group)) {\n                                for (let [k,v] of result.entries()) {\n                                    if (~k.indexOf(group)) {\n                                        resultGroup = v;\n                                    }\n                                }\n                            }\n                            if (resultGroup) {\n                                foundValues.set(group, resultGroup)\n                            }\n                        })\n                    }\n                    for (let [dKey,dValue] of modelData.get('foundValues').entries()) {\n                        foundValues.set(dKey, dValue);\n                    }\n                    for (let [eKey,eValue] of modelData.get('equalCols').entries()) {\n                        foundValues.set(eValue, foundValues.get(eKey))\n                    }\n                    finder.set(finder.size, new Map(Array.from(foundValues.entries()).sort()));\n                });\n                toFill.set(modelName, finder);\n            }\n            return toFill;\n        }).then(toFill => {\n            return this.models.map(model => {\n                let name = model.constructor.name;\n                model.functionsAfterParse.forEach(func => {\n                    Promise.resolve(model._getFunctions(func)({\n                        table: name,\n                        fields: toFill.get(name)\n                    })).then(val => val);\n                });\n            });\n        });\n    }\n\n    valueFunctions(text, column, models) {\n        let tmp = column[0];\n        this.models.forEach(model => {\n            if (models.get(model.constructor.name).get('valueOptions').has(tmp)) {\n                let all = models.get(model.constructor.name).get('valueOptions').get(tmp);\n                Object.keys(all).forEach(val => {\n                    if (~['replace', 'regex'].indexOf(val)) {\n                        let re = new RegExp(Object.keys(all[val]).join(\"|\"), \"gi\");\n                        text = text.replace(re, matched => all[val][matched]);\n                    }\n                });\n            }\n        });\n        return text;\n    }\n\n    createDotNotation(arr, name) {\n        return arr.map(val => val.name).join('.') + (name ? '.' + name : '');\n    }\n\n    parseString(xml, models, options) {\n        if ('object' === typeof models && models.toDotNotation === true) {\n            return Promise.resolve(this.getDotNotation(xml));\n        }\n        return Promise.resolve(this.parse(xml, models, options));\n    }\n\n    parseFile(file, models, options) {\n        if ('object' === typeof models && models.toDotNotation === true) {\n            return fs.readFileAsync(file).then(val => this.getDotNotation(val.toString()));\n        }\n        return fs.readFileAsync(file).then(val => this.parse(val.toString(), models, options));\n    }\n\n    getDotNotation(xml) {\n        let dotNotated = [];\n        this.parser.ontext = text => {\n            let parser = this.parser;\n            dotNotated.push(this.createDotNotation(parser.tags, parser.tag.name))\n        };\n        this.parser.write(xml).close();\n        return dotNotated.filter((item, pos, self) => self.indexOf(item) == pos);\n    }\n\n}\n\nmodule.exports = XmlParser;\n\n"]}